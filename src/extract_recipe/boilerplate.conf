# Pattern configuration for extract-recipe.
#
# Sections, separated by a [section] header:
#
#   [strip]  — regexes applied to prompt text with re.sub(pattern, "", text).
#              Include leading \n* to consume blank lines left behind.
#
#   [skip]   — regexes matched against the raw .display field.
#              If a prompt matches, it is omitted entirely from the recipe.
#
#   [plan]   — regexes matched against the raw .display field.
#              If a prompt matches, it is collapsed to a title summary.
#
#   [redact] — pattern = replacement pairs for sensitive content.
#              Applied with re.sub(pattern, replacement, text) when -r is used.
#
#   [audit-stopwords] — case-insensitive regexes matched with re.fullmatch
#              against each capitalised word in prompts.  Write in lowercase;
#              e.g. add(ed|ing)? matches Add, Added, Adding.  --audit --raw
#              bypasses this list.
#
# Processing order:  [skip] → [strip] → [plan] → [redact]
#   1. Entries matching [skip] are removed entirely
#   2. [strip] patterns are applied to the remaining entries' text
#   3. [plan] patterns are checked to collapse plan prompts to a title
#   4. [redact] patterns replace sensitive content (only with -r flag)
#
# Blank lines and lines starting with # are ignored.
# To add support for another tool (Codex, Antigravity, etc.), append
# patterns below and send a PR.
#
# To customise, run:
#   extract-recipe --init-config
# This copies this file to ~/.config/extract-recipe/patterns.conf
# which you can then edit.  The user config replaces (not extends)
# the package defaults.  Use --config FILE to load from another path.

# =====================================================================
# Claude Code (developed against 2.1.45)
# =====================================================================

[strip]

# Plan-mode transcript reference appended to .display in history.jsonl.
# Matches any line containing a .claude/projects/.../*.jsonl path.
\n*[^\n]*\.claude/projects/[^\n]*\.jsonl

[skip]

# Housekeeping slash commands — no recipe value.
^/config\s*$
^/login\s*$
^/status\s*$
^/statusline\b
^/release-notes\s*$
^/rate-limit-options\s*$
^/upgrade\s*$
^/rewind\s*$

[plan]

# Plan-mode prompts: collapsed to a title summary by default.
^Implement the following plan:

[redact]

# Home directory paths — replace with ~
/(Users|home)/\w+ = ~

# Temporary directory paths — strip username component
/tmp/\w+ = /tmp

# AWS access keys
AKIA[0-9A-Z]{16} = [REDACTED]

# GitHub tokens (PAT, app, OAuth, fine-grained)
ghp_[A-Za-z0-9]{36,} = [REDACTED]
ghs_[A-Za-z0-9]{36,} = [REDACTED]
gho_[A-Za-z0-9]{36,} = [REDACTED]
github_pat_[A-Za-z0-9_]{59,} = [REDACTED]

# Anthropic API keys
sk-ant-[A-Za-z0-9_-]{20,} = [REDACTED]

# OpenAI keys (project and standard)
sk-proj-[A-Za-z0-9_-]{20,} = [REDACTED]
sk-[A-Za-z0-9]{20,} = [REDACTED]

# Google API keys
AIza[A-Za-z0-9_-]{35} = [REDACTED]

[audit-stopwords]

# Case-insensitive regexes matched with re.fullmatch against each
# capitalised word found in prompts.  Write patterns in lowercase;
# matching is case-insensitive so "add(ed)?" matches "Add" and "Added".
# Remove entries to let those words appear in --audit output.
# Use --audit --raw to bypass this list entirely.

# Articles, pronouns, prepositions, conjunctions, determiners
a(fter|n|ll|lready|lso|lways|nother|ny|t)?
and
are
as
be(cause|en|fore|ing|low|sides|tween)?
both
but
by
each
either
else
even
every
for
from
he
her(e|s)?
his
how(ever)?
if
in(clude|stead|to)?
is
it(s)?
just
know
like
many
may(be)?
me
might
more
most
much
must
my
no(t|thing|w|ne)?
of
on(ce|ly)?
or
other
our
out
over
own
per
same
she
since
so(me)?
still
such
than
th(at|e|eir|em|en|ere|ese|ey|is|ose|ree|rough)
to(o)?
two
under
until
up
us
very
was
way
we(ll|re)?
wh(at|en|ere|ich|ile|o|y)
will
with(out)?
would
yes
yet
you(r)?

# Common verbs
achiev(e|ed|ing)
add(ed|ing|s)?
approach(es|ed)?
assess(ed|ing|ment|s)?
avail.*
bas(ed|ic)
build(s|ing)?
can
chang(e|ed|es|ing)
check(ed|ing|s)?
clean(ed|ing|s)?
clear(ed|ing|s)?
combin(e|ed|ing)
complet(e|ed|ing)
consider(ed|ing)?
contain(ed|ing|s)?
could
creat(e|ed|ing|ion)
defin(e|ed|ing|ition)
did
do(es|ne)?
ensur(e|ed|ing)
exist(ed|ing|s)?
expect(ed|ing|s)?
find(s|ing)?
fix(ed|es|ing)?
flip(ped|s)?
follow(ed|ing|s)?
generat(e|ed|ing|ion)
get(s|ting)?
giv(e|en|ing)
go(ing|t|od)?
guess(ed|ing)?
had
handl(e|ed|ing)
ha(s|ve|ving)
implement(ation|ed|ing|s)?
import(ant|ed|ing)?
keep(s|ing)?
let
look(ed|ing|s)?
mak(e|ing)
modif(y|ied|ying)
mov(e|ed|ing)
need(ed|ing|s)?
pla(n|nned|nning)
pleas(e|ed)?
print(ed|ing|s)?
prov(e|ed|es|ing|ision)
provid(e|ed|ing)
put(s|ting)?
read(s|ing)?
relat(e|ed|ing|ion)
remain(ed|ing|s)?
remov(e|ed|ing)
replac(e|ed|ing)
return(ed|ing|s)?
run(s|ning)?
said
say(s|ing)?
see(ms?|ing|n)?
set(s|ting)?
should
show(ed|ing|n|s)?
simulat(e|ed|ing|ion|ions)
skip(ped|ping|s)?
start(ed|ing|s)?
stop(ped|ping|s)?
take(n|s)?
tell(s|ing)?
think(s|ing)?
tr(y|ied|ying)
updat(e|ed|ing|es)
us(e|ed|es|ing)
verif(y|ied|ying|ication)
want(ed|ing|s)?
writ(e|ing|ten)
work(ed|ing|s)?

# Common nouns and adjectives
about
action(s)?
actual(ly)?
analy(sis|ses)
availabl(e|y)
cas(e|es)
categor(y|ies)
chain(ed|s)?
code
concret(e|ly)
cor(e|rect|rection)
current(ly)?
descript(ion|ions)
document(ation|s)?
effort(s)?
encod(e|ed|ing)
essential(ly)?
file(s)?
final(ly)?
first
forward
gap(s)?
general(ly)?
goal(s)?
great
hmm
horizon(tal)?
key(s)?
last
lin(e|es)
list(ed|ing|s)?
locat(e|ed|ion|ions)
low(er)?
machin(e|es)
main(ly)?
makefile
medi.*
new
next
non
opt(ion|ions|ional)
output(s)?
part(s|ial|ly)?
phas(e|es)
preliminar(y|ies)
priorit(y|ies|ize)
proof(s)?
propert(y|ies)
refer(ence|ences)
result(ed|ing|s)?
right
row(s)?
second(ly)?
sort(ed|ing)?
sorry
specif(ic|ied|ying)
standard(s)?
stat(e|es|ic)
status
step(s)?
strateg(y|ies|ic)
structur(e|ed|es|al)
summar(y|ies)
task(s)?
tru(e|ly|th)
test(ed|ing|s)?
tim(e|es|ing)
univers(al|e|ity)
user(s)?
valu(e|es)

# --- Uncomment patterns below as needed ---

# ORCID identifiers (uniquely identify a person)
# https://orcid\.org/\d{4}-\d{4}-\d{4}-\d{3}[\dX] = [ORCID]

# GitHub profile/repo URLs (may identify the user)
# https://github\.com/[A-Za-z0-9_.-]+(?:/[A-Za-z0-9_.-]+)? = [GITHUB-URL]
